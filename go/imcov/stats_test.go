package imcov

import (
	"math"
	"testing"

	"github.com/jvlmdr/go-cv/rimg64"
)

func TestMeanSum(t *testing.T) {
	M, N, k := 5, 3, 2
	m, n := 3, 2

	im := rimg64.NewMulti(M, N, k)
	// Row 0, channel 0.
	im.Set(0, 0, 0, 1)
	im.Set(1, 0, 0, 0)
	im.Set(2, 0, 0, 2)
	im.Set(3, 0, 0, 1)
	im.Set(4, 0, 0, 1)
	// Row 1, channel 0.
	im.Set(0, 1, 0, 0)
	im.Set(1, 1, 0, 3)
	im.Set(2, 1, 0, 5)
	im.Set(3, 1, 0, 0)
	im.Set(4, 1, 0, 0)
	// Row 2, channel 0.
	im.Set(0, 2, 0, 2)
	im.Set(1, 2, 0, 1)
	im.Set(2, 2, 0, 0)
	im.Set(3, 2, 0, 3)
	im.Set(4, 2, 0, 2)

	// Row 0, channel 1.
	im.Set(0, 0, 1, 2)
	im.Set(1, 0, 1, 0)
	im.Set(2, 0, 1, 3)
	im.Set(3, 0, 1, 5)
	im.Set(4, 0, 1, 5)
	// Row 1, channel 1.
	im.Set(0, 1, 1, 1)
	im.Set(1, 1, 1, 2)
	im.Set(2, 1, 1, 4)
	im.Set(3, 1, 1, 0)
	im.Set(4, 1, 1, 1)
	// Row 2, channel 1.
	im.Set(0, 2, 1, 4)
	im.Set(1, 2, 1, 0)
	im.Set(2, 2, 1, 5)
	im.Set(3, 2, 1, 5)
	im.Set(4, 2, 1, 4)

	cov := MeanSum(im, m, n)
	cases := []struct {
		U, V, P int
		Want    float64
	}{
		// Channel 0
		{0, 0, 0, (1 + 0 + 2) + (0 + 3 + 5)},
		{1, 0, 0, (0 + 2 + 1) + (3 + 5 + 0)},
		{2, 0, 0, (2 + 1 + 1) + (5 + 0 + 0)},
		{0, 1, 0, (0 + 3 + 5) + (2 + 1 + 0)},
		{1, 1, 0, (3 + 5 + 0) + (1 + 0 + 3)},
		{2, 1, 0, (5 + 0 + 0) + (0 + 3 + 2)},
		// Channel 1
		{0, 0, 1, (2 + 0 + 3) + (1 + 2 + 4)},
		{1, 0, 1, (0 + 3 + 5) + (2 + 4 + 0)},
		{2, 0, 1, (3 + 5 + 5) + (4 + 0 + 1)},
		{0, 1, 1, (1 + 2 + 4) + (4 + 0 + 5)},
		{1, 1, 1, (2 + 4 + 0) + (0 + 5 + 5)},
		{2, 1, 1, (4 + 0 + 1) + (5 + 5 + 4)},
	}

	for _, e := range cases {
		got := cov.At(e.U, e.V, e.P)
		if math.Abs(got-e.Want) > 1e-6 {
			t.Errorf(
				"different: at (%d, %d, %d): want %.6g, got %.6g",
				e.U, e.V, e.P, e.Want, got,
			)
		}
	}
}

func TestCovarSum(t *testing.T) {
	M, N, k := 5, 3, 2
	m, n := 3, 2

	im := rimg64.NewMulti(M, N, k)
	// Row 0, channel 0.
	im.Set(0, 0, 0, 1)
	im.Set(1, 0, 0, 0)
	im.Set(2, 0, 0, 2)
	im.Set(3, 0, 0, 1)
	im.Set(4, 0, 0, 1)
	// Row 1, channel 0.
	im.Set(0, 1, 0, 0)
	im.Set(1, 1, 0, 3)
	im.Set(2, 1, 0, 5)
	im.Set(3, 1, 0, 0)
	im.Set(4, 1, 0, 0)
	// Row 2, channel 0.
	im.Set(0, 2, 0, 2)
	im.Set(1, 2, 0, 1)
	im.Set(2, 2, 0, 0)
	im.Set(3, 2, 0, 3)
	im.Set(4, 2, 0, 2)

	// Row 0, channel 1.
	im.Set(0, 0, 1, 2)
	im.Set(1, 0, 1, 0)
	im.Set(2, 0, 1, 3)
	im.Set(3, 0, 1, 5)
	im.Set(4, 0, 1, 5)
	// Row 1, channel 1.
	im.Set(0, 1, 1, 1)
	im.Set(1, 1, 1, 2)
	im.Set(2, 1, 1, 4)
	im.Set(3, 1, 1, 0)
	im.Set(4, 1, 1, 1)
	// Row 2, channel 1.
	im.Set(0, 2, 1, 4)
	im.Set(1, 2, 1, 0)
	im.Set(2, 2, 1, 5)
	im.Set(3, 2, 1, 5)
	im.Set(4, 2, 1, 4)

	cov := CovarSum(im, m, n)
	cases := []struct {
		U, V, P int
		I, J, Q int
		Want    float64
	}{
		// Channel 0 to 0, row 0 in (u, v)
		// (u, v) = (0, 0)
		{0, 0, 0, 0, 0, 0, (1*1 + 0*0 + 2*2) + (0*0 + 3*3 + 5*5)},
		{0, 0, 0, 1, 0, 0, (1*0 + 0*2 + 2*1) + (0*3 + 3*5 + 5*0)},
		{0, 0, 0, 2, 0, 0, (1*2 + 0*1 + 2*1) + (0*5 + 3*0 + 5*0)},
		{0, 0, 0, 0, 1, 0, (1*0 + 0*3 + 2*5) + (0*2 + 3*1 + 5*0)},
		{0, 0, 0, 1, 1, 0, (1*3 + 0*5 + 2*0) + (0*1 + 3*0 + 5*3)},
		{0, 0, 0, 2, 1, 0, (1*5 + 0*0 + 2*0) + (0*0 + 3*3 + 5*2)},
		// (u, v) = (1, 0)
		{1, 0, 0, 0, 0, 0, (0*1 + 2*0 + 1*2) + (3*0 + 5*3 + 0*5)},
		{1, 0, 0, 1, 0, 0, (0*0 + 2*2 + 1*1) + (3*3 + 5*5 + 0*0)},
		{1, 0, 0, 2, 0, 0, (0*2 + 2*1 + 1*1) + (3*5 + 5*0 + 0*0)},
		{1, 0, 0, 0, 1, 0, (0*0 + 2*3 + 1*5) + (3*2 + 5*1 + 0*0)},
		{1, 0, 0, 1, 1, 0, (0*3 + 2*5 + 1*0) + (3*1 + 5*0 + 0*3)},
		{1, 0, 0, 2, 1, 0, (0*5 + 2*0 + 1*0) + (3*0 + 5*3 + 0*2)},
		// (u, v) = (2, 0)
		{2, 0, 0, 0, 0, 0, (2*1 + 1*0 + 1*2) + (5*0 + 0*3 + 0*5)},
		{2, 0, 0, 1, 0, 0, (2*0 + 1*2 + 1*1) + (5*3 + 0*5 + 0*0)},
		{2, 0, 0, 2, 0, 0, (2*2 + 1*1 + 1*1) + (5*5 + 0*0 + 0*0)},
		{2, 0, 0, 0, 1, 0, (2*0 + 1*3 + 1*5) + (5*2 + 0*1 + 0*0)},
		{2, 0, 0, 1, 1, 0, (2*3 + 1*5 + 1*0) + (5*1 + 0*0 + 0*3)},
		{2, 0, 0, 2, 1, 0, (2*5 + 1*0 + 1*0) + (5*0 + 0*3 + 0*2)},

		// Channel 0 to 0, row 1 in (u, v)
		// (u, v) = (0, 1)
		{0, 1, 0, 0, 0, 0, (0*1 + 3*0 + 5*2) + (2*0 + 1*3 + 0*5)},
		{0, 1, 0, 1, 0, 0, (0*0 + 3*2 + 5*1) + (2*3 + 1*5 + 0*0)},
		{0, 1, 0, 2, 0, 0, (0*2 + 3*1 + 5*1) + (2*5 + 1*0 + 0*0)},
		{0, 1, 0, 0, 1, 0, (0*0 + 3*3 + 5*5) + (2*2 + 1*1 + 0*0)},
		{0, 1, 0, 1, 1, 0, (0*3 + 3*5 + 5*0) + (2*1 + 1*0 + 0*3)},
		{0, 1, 0, 2, 1, 0, (0*5 + 3*0 + 5*0) + (2*0 + 1*3 + 0*2)},
		// (u, v) = (1, 1)
		{1, 1, 0, 0, 0, 0, (3*1 + 5*0 + 0*2) + (1*0 + 0*3 + 3*5)},
		{1, 1, 0, 1, 0, 0, (3*0 + 5*2 + 0*1) + (1*3 + 0*5 + 3*0)},
		{1, 1, 0, 2, 0, 0, (3*2 + 5*1 + 0*1) + (1*5 + 0*0 + 3*0)},
		{1, 1, 0, 0, 1, 0, (3*0 + 5*3 + 0*5) + (1*2 + 0*1 + 3*0)},
		{1, 1, 0, 1, 1, 0, (3*3 + 5*5 + 0*0) + (1*1 + 0*0 + 3*3)},
		{1, 1, 0, 2, 1, 0, (3*5 + 5*0 + 0*0) + (1*0 + 0*3 + 3*2)},
		// (u, v) = (2, 1)
		{2, 1, 0, 0, 0, 0, (5*1 + 0*0 + 0*2) + (0*0 + 3*3 + 2*5)},
		{2, 1, 0, 1, 0, 0, (5*0 + 0*2 + 0*1) + (0*3 + 3*5 + 2*0)},
		{2, 1, 0, 2, 0, 0, (5*2 + 0*1 + 0*1) + (0*5 + 3*0 + 2*0)},
		{2, 1, 0, 0, 1, 0, (5*0 + 0*3 + 0*5) + (0*2 + 3*1 + 2*0)},
		{2, 1, 0, 1, 1, 0, (5*3 + 0*5 + 0*0) + (0*1 + 3*0 + 2*3)},
		{2, 1, 0, 2, 1, 0, (5*5 + 0*0 + 0*0) + (0*0 + 3*3 + 2*2)},

		// TODO: Channel pairs (0, 1) and (1, 1).
	}

	for _, e := range cases {
		got := cov.At(e.U, e.V, e.P, e.I, e.J, e.Q)
		if math.Abs(got-e.Want) > 1e-6 {
			t.Errorf(
				"different: at (%d, %d, %d), (%d, %d, %d): want %.6g, got %.6g",
				e.U, e.V, e.P, e.I, e.J, e.Q, e.Want, got,
			)
		}
	}
}
